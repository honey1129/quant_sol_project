import os
import joblib
import traceback
import numpy as np
from core.signal_engine import SignalSmoother, bayesian_weighted_predict, load_models
from utils.utils import log_info, log_error, BASE_DIR
from config import config
from core.okx_api import OKXClient
from core.ml_feature_engineering import merge_multi_period_features, add_advanced_features
from core.position_manager import PositionManager

# åˆå§‹åŒ–å¯¹è±¡
client = OKXClient()
position_manager = PositionManager()
smoother = SignalSmoother(alpha=float(config.SMOOTH_ALPHA))  # alphaæ³¨æ„å¼ºè½¬ä¸ºfloat

# æ­¢ç›ˆæ­¢æŸé€»è¾‘
def risk_control():
    market_price = client.get_price()
    long_pos, short_pos = client.get_position()

    has_action = False  # æ˜¯å¦æ‰§è¡Œäº†å¹³ä»“åŠ¨ä½œ

    # å¤šä»“é£æ§
    if long_pos['size'] > 0:
        entry_price = long_pos['entry_price']
        size = long_pos['size']
        pnl_pct = (market_price - entry_price) / entry_price
        profit_amount = (market_price - entry_price) * size
        usd_amount = size * entry_price / config.LEVERAGE

        if pnl_pct >= config.TAKE_PROFIT:
            client.close_long(usd_amount, config.LEVERAGE)
            log_info(f"âœ… LONG æ­¢ç›ˆå¹³ä»“ï¼Œæ”¶ç›Šç‡: {pnl_pct*100:.2f}%, ç›ˆåˆ©: {profit_amount:.2f} USD")
            has_action = True
        elif pnl_pct <= -config.STOP_LOSS:
            client.close_long(usd_amount, config.LEVERAGE)
            log_info(f"âŒ LONG æ­¢æŸå¹³ä»“ï¼Œæ”¶ç›Šç‡: {pnl_pct*100:.2f}%, äºæŸ: {profit_amount:.2f} USD")
            has_action = True

    # ç©ºä»“é£æ§
    if short_pos['size'] > 0:
        entry_price = short_pos['entry_price']
        size = short_pos['size']
        pnl_pct = (entry_price - market_price) / entry_price
        profit_amount = (entry_price - market_price) * size
        usd_amount = size * entry_price / config.LEVERAGE

        if pnl_pct >= config.TAKE_PROFIT:
            client.close_short(usd_amount, config.LEVERAGE)
            log_info(f"âœ… SHORT æ­¢ç›ˆå¹³ä»“ï¼Œæ”¶ç›Šç‡: {pnl_pct*100:.2f}%, ç›ˆåˆ©: {profit_amount:.2f} USD")
            has_action = True
        elif pnl_pct <= -config.STOP_LOSS:
            client.close_short(usd_amount, config.LEVERAGE)
            log_info(f"âŒ SHORT æ­¢æŸå¹³ä»“ï¼Œæ”¶ç›Šç‡: {pnl_pct*100:.2f}%, äºæŸ: {profit_amount:.2f} USD")
            has_action = True

    # æ— å¹³ä»“åŠ¨ä½œåˆ™æ‰“å°å½“å‰æŒä»“ä¿¡æ¯ + æµ®åŠ¨ç›ˆäº
    if not has_action:
        if long_pos['size'] > 0:
            pnl = (market_price - long_pos['entry_price']) * long_pos['size']
            pnl_pct = (market_price - long_pos['entry_price']) / long_pos['entry_price'] * 100
            log_info(f"ğŸ“Š å½“å‰LONGæŒä»“: {long_pos['size']}å¼ ï¼Œæˆæœ¬: {long_pos['entry_price']}, å½“å‰ä»·: {market_price}, æµ®ç›ˆ: {pnl:.2f} USD ({pnl_pct:.2f}%)")
        if short_pos['size'] > 0:
            pnl = (short_pos['entry_price'] - market_price) * short_pos['size']
            pnl_pct = (short_pos['entry_price'] - market_price) / short_pos['entry_price'] * 100
            log_info(f"ğŸ“Š å½“å‰SHORTæŒä»“: {short_pos['size']}å¼ ï¼Œæˆæœ¬: {short_pos['entry_price']}, å½“å‰ä»·: {market_price}, æµ®ç›ˆ: {pnl:.2f} USD ({pnl_pct:.2f}%)")
        if long_pos['size'] == 0 and short_pos['size'] == 0:
            log_info(f"ğŸ“Š å½“å‰æ— æŒä»“ï¼Œé£æ§ç›‘æ§ä¸­...")




# é¢„æµ‹ä¿¡å·æ¨¡å—
def predict_signal(model_dict, model_weights):
    data_dict = client.fetch_data()
    merged_df = merge_multi_period_features(data_dict)
    merged_df = add_advanced_features(merged_df)

    feature_path = os.path.join(BASE_DIR, config.FEATURE_LIST_PATH)
    feature_cols = joblib.load(feature_path)

    prob = bayesian_weighted_predict(model_dict, merged_df, feature_cols, model_weights)
    smoothed_prob = smoother.smooth(prob)

    long_prob, short_prob = smoothed_prob[1], smoothed_prob[0]
    money_flow_ratio = merged_df['money_flow_ratio'].iloc[-1]
    merged_df['log_return'] = np.log(merged_df['5m_close'] / merged_df['5m_close'].shift(1))
    volatility = merged_df['log_return'].rolling(288).std().iloc[-1] * np.sqrt(288)

    log_info(f"å®æ—¶é¢„æµ‹ - å¤š: {long_prob:.3f} ç©º: {short_prob:.3f} (å¹³æ»‘å)")
    log_info(f"ç‰¹å¾ç›‘æ§ - èµ„é‡‘æµ: {money_flow_ratio:.3f} æ³¢åŠ¨ç‡: {volatility:.5f}")

    return long_prob, short_prob, money_flow_ratio, volatility

# ä»“ä½è°ƒæ•´æ ¸å¿ƒ
def adjust_position(long_prob, short_prob, money_flow_ratio, volatility):
    account_balance = client.get_account_balance()
    usdt_balance = float(account_balance['data'][0]['availEq'])

    long_pos, short_pos = client.get_position()

    adjusted_balance = position_manager.volatility_adjust_balance(usdt_balance, volatility)
    max_position_value = usdt_balance * float(config.MAX_POSITION_RATIO)
    MIN_ADJUST_AMOUNT = float(config.MIN_ADJUST_AMOUNT)

    # å¤šä»“é€»è¾‘
    if long_prob > config.THRESHOLD_LONG:
        target_ratio = position_manager.calculate_target_ratio(long_prob, money_flow_ratio, volatility)
        target_value = min(adjusted_balance * target_ratio, max_position_value)
        current_value = long_pos['size'] * long_pos['entry_price']
        delta_value = target_value - current_value
        delta_principal = delta_value / config.LEVERAGE

        if delta_principal > MIN_ADJUST_AMOUNT:
            client.open_long(delta_principal, config.LEVERAGE)
            log_info(f"ğŸ“ˆ åŠ å¤šä»“: {delta_principal:.2f} USD æœ¬é‡‘ (ç›®æ ‡ä»“ä½: {target_ratio*100:.2f}%)")
        elif delta_principal < -MIN_ADJUST_AMOUNT:
            client.close_long(abs(delta_principal), config.LEVERAGE)
            log_info(f"ğŸ“‰ å‡å¤šä»“: {abs(delta_principal):.2f} USD æœ¬é‡‘ (ç›®æ ‡ä»“ä½: {target_ratio*100:.2f}%)")
        else:
            log_info("ğŸŸ¢ å¤šä»“å·²è¾¾ç›®æ ‡ï¼Œæ— éœ€è°ƒæ•´")

    # ç©ºä»“é€»è¾‘
    if short_prob > config.THRESHOLD_SHORT:
        target_ratio = position_manager.calculate_target_ratio(short_prob, money_flow_ratio, volatility)
        target_value = min(adjusted_balance * target_ratio, max_position_value)
        current_value = short_pos['size'] * short_pos['entry_price']
        delta_value = target_value - current_value
        delta_principal = delta_value / config.LEVERAGE

        if delta_principal > MIN_ADJUST_AMOUNT:
            client.open_short(delta_principal, config.LEVERAGE)
            log_info(f"ğŸ“ˆ åŠ ç©ºä»“: {delta_principal:.2f} USD æœ¬é‡‘ (ç›®æ ‡ä»“ä½: {target_ratio*100:.2f}%)")
        elif delta_principal < -MIN_ADJUST_AMOUNT:
            client.close_short(abs(delta_principal), config.LEVERAGE)
            log_info(f"ğŸ“‰ å‡ç©ºä»“: {abs(delta_principal):.2f} USD æœ¬é‡‘ (ç›®æ ‡ä»“ä½: {target_ratio*100:.2f}%)")
        else:
            log_info("ğŸŸ¢ ç©ºä»“å·²è¾¾ç›®æ ‡ï¼Œæ— éœ€è°ƒæ•´")

    # æ— æ˜æ˜¾ä¿¡å·æ—¶
    if not (long_prob > config.THRESHOLD_LONG or short_prob > config.THRESHOLD_SHORT):
        log_info("ğŸ“Š å½“å‰æ— æ˜æ˜¾ä¿¡å·ï¼Œä»“ä½ä¿æŒä¸å˜")


# ä¸»è¿è¡Œå…¥å£
def run():
    try:
        # 1. æ¨¡å‹åŠ è½½
        model_paths = {name: os.path.join(BASE_DIR, path) for name, path in config.MODEL_PATHS.items()}
        model_dict = load_models(model_paths)
        model_weights = config.MODEL_WEIGHTS

        # 2. é£æ§æ­¢ç›ˆæ­¢æŸï¼ˆå…ˆå¹³ä»“ï¼Œé¿å…åç»­é‡å¤è°ƒæ•´ï¼‰
        risk_control()

        # 3. è·å–æ–°é¢„æµ‹ä¿¡å·
        long_prob, short_prob, money_flow_ratio, volatility = predict_signal(model_dict, model_weights)

        # 4. æ ¹æ®æœ€æ–°ä¿¡å·åŠ¨æ€è°ƒä»“
        adjust_position(long_prob, short_prob, money_flow_ratio, volatility)

    except Exception as e:
        log_error(f"å®ç›˜è¿è¡Œå¼‚å¸¸: {e}")
        log_error(traceback.format_exc())


if __name__ == '__main__':
    run()
